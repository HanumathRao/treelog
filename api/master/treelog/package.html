<?xml version='1.0' encoding='UTF-8'?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html>
        <head>
          <title>treelog - treelog</title>
          <meta name="description" content="treelog - treelog" />
          <meta name="keywords" content="treelog treelog" />
          <meta http-equiv="content-type" content="text/html; charset=UTF-8" />
          
      <link href="../lib/template.css" media="screen" type="text/css" rel="stylesheet" />
      <link href="../lib/diagrams.css" media="screen" type="text/css" rel="stylesheet" id="diagrams-css" />
      <script type="text/javascript">
         if(top === self) {
            var url = '../index.html';
            var hash = 'treelog.package';
            var anchor = window.location.hash;
            var anchor_opt = '';
            if (anchor.length >= 1)
              anchor_opt = '@' + anchor.substring(1);
            window.location.href = url + '#' + hash + anchor_opt;
         }
   	  </script>
    
        </head>
        <body class="value">
      <div id="definition">
        <img src="../lib/package_big.png" />
        
        <h1>treelog</h1>
      </div>

      <h4 id="signature" class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">package</span>
      </span>
      <span class="symbol">
        <span class="name">treelog</span>
      </span>
      </h4>
      
          <div id="comment" class="fullcommenttop"><div class="comment cmt"><h3>Introduction</h3><p>TreeLog enables logging as a tree structure so that comprehensive logging does not become incomprehensible.</p><p>It is often necessary to understand exactly what happened in a computation, not just that it succeeded or failed, but what was actually done
and with what data. TreeLog produces a description of a computation (along with a result) as a hierarchical log of
computations that led to the result. The tree could be logged as text or stored in a database so that users can see
a detailed audit trail of the processing that has occurred for particular entities.</p><p>Note that in the remainder of this document, results of producing log trees will be shown by rendering
the tree textually, but that is only one possible way.</p><p>Nodes in the log tree can be annotated with important information for your program to use later. This is useful, for example, when you want to audit
a process that affects multiple entities, and you want to ensure that the audit trail is associated with each of the modified entities.</p><h3>DescribedComputation</h3><p>All of this works by 'lifting' the intermediate and final results of computations and the description of the steps into a type called <code>DescribedComputation</code>
(declared in <a href="LogTreeSyntax.html" class="extype" name="treelog.LogTreeSyntax">LogTreeSyntax</a>.</p><h4>Some Simple Lifting</h4><p>You can produce a <code>DescribedComputation</code> very simply with many of the methods in <a href="LogTreeSyntax.html" class="extype" name="treelog.LogTreeSyntax">LogTreeSyntax</a>. The simplest few are:</p><pre><span class="cmt">// This is a concrete implementation of LogTreeSyntax that is provided for you</span>
<span class="cmt">// to use if you don't need to use annotations (see later)</span>
<span class="kw">import</span> treelog.LogTreeSyntaxWithoutAnnotations._

<span class="kw">val</span> result1 = success(<span class="num">2</span> * <span class="num">3</span>, <span class="lit">"Calculated product"</span>)
<span class="cmt">// result1 is now a DescribedComputation and carries the successful result and</span>
<span class="cmt">// a single node tree telling us that the product was calculated. See below for how to</span>
<span class="cmt">// extract these things.</span>

<span class="kw">val</span> result2 = failure(<span class="lit">"It's all wrong"</span>)
<span class="cmt">// result2 is now a DescribedComputation whose value and tree both tell us that things</span>
<span class="cmt">// went wrong</span>

<span class="kw">val</span> result3 = (<span class="num">2</span> * <span class="num">3</span>) ~&gt; <span class="lit">"Calculated product"</span>
<span class="cmt">// The same as result1</span>

 <span class="kw">val</span> result4 = (<span class="num">2</span> * <span class="num">3</span>) ~&gt; (p <span class="kw">=&gt;</span> <span class="lit">"Calculated product: "</span> + p)
<span class="cmt">// The same as result1, except the description in the tree node will be "Calculated product: 6"</span></pre><p><code>result3</code> and <code>result4</code> above introduce the first pieces of syntax related to producing
<code>DescribedComputations</code>. In this case it lifts the value into the <code>DescribedComputation</code>
and creates a leaf node in the associated log tree. See <a href="LogTreeSyntax$LeafSyntax.html" class="extype" name="treelog.LogTreeSyntax.LeafSyntax">LeafSyntax</a> for
related simple syntax for leaves.</p><h4> Extracting the Result and Log </h4><p>When a computation result is 'lifted' into a <code>DescribedComputation</code> by one of the many methods
in the <a href="LogTreeSyntax.html" class="extype" name="treelog.LogTreeSyntax">LogTreeSyntax</a> trait, it is possible to retrieve the 'value' of the computation like this:</p><pre><span class="kw">import</span> treelog.LogTreeSyntaxWithoutAnnotations._
<span class="kw">val</span> foo = <span class="num">1</span> ~&gt; <span class="lit">"Here's one"</span>
<span class="kw">val</span> value = foo.run.value
<span class="cmt">// value will now be equal to scalaz.\/-(1), which represents a successful computation.</span></pre><p>The 'value' is a scalaz 'Either' (scalaz.\/). Following the usual convention:</p><ul><li>If it a 'left' (-\/) then the computation is a failure.</li><li>If it is a 'right' (\/-), then the computation is a success.</li></ul><p>Likewise, it is possible to retrieve the log tree like this:</p><pre><span class="kw">import</span> treelog.LogTreeSyntaxWithoutAnnotations._
<span class="kw">val</span> foo = <span class="num">1</span> ~&gt; <span class="lit">"Here's one"</span>
<span class="kw">val</span> logtree = foo.run.written
<span class="cmt">// logtree will now be an instance of LogTree which is a type alias which in this case expands to:</span>
<span class="cmt">// TreeNode[LogTreeLabel[Nothing]](DescribedLogTreeLabel[Nothing]("Here's one", true, Set[Nothing]())</span>
<span class="cmt">// Where:</span>
<span class="cmt">//   - "Here's one" is the description provided in the declaration of foo</span>
<span class="cmt">//   - true indicates that the computation represented by the node was successful</span>
<span class="cmt">//   - the empty set represents the annotations specified for this node</span></pre><p>It may seem strange that both the <code>value</code> and the log tree provide indications of success and failure (the <code>value</code>
through the use of <code>scalaz.\/</code>, and the log tree with a <code>boolean</code> property in the <a href="TreeNode.html" class="extype" name="treelog.TreeNode">TreeNode</a> label.
The reason for this is that part of a computation may fail (which we want to indicate in the log tree), but then a different strategy
is tried which succeeds leading to a successful overall result.</p><h4> More Comprehensive Computations </h4><p>(An extended example of this kind of thing is the
<a href="https://github.com/lancewalton/treelog/blob/master/src/test/scala/QuadraticRootsExample.scala" target="_blank">quadratic roots example on GitHub</a>)</p><p>Generally, once a value has been lifted, it is a good idea to keep working with it in that form for as long
as possible before accessing the <code>value</code> and <code>written</code> properties. Think monadically!
The examples above show a value being lifted into the DescribedComputation. To continue to work monadically,
for-comprehensions come into play:</p><pre><span class="kw">import</span> treelog.LogTreeSyntaxWithoutAnnotations._
<span class="kw">import</span> scalaz.syntax.show._

<span class="kw">val</span> result = <span class="kw">for</span> {
   foo <span class="kw">&lt;-</span> <span class="num">1</span> ~&gt; (<span class="lit">"foo = "</span> + _) <span class="cmt">// Using the overload of ~> that gives us the 'value'</span>
   bar <span class="kw">&lt;-</span> <span class="num">2</span> ~&gt; (<span class="lit">"bar = "</span> + _) <span class="cmt">// so that we can include it in the log messages</span>
   foobar <span class="kw">&lt;-</span> (foo + bar) ~&gt; (<span class="lit">"foobar = "</span> + _)
  } <span class="kw">yield</span> foobar

println(result.run.value)
<span class="cmt">// Will print \/-(3) (i.e. a successful computation of 1 + 2)</span>

println(result.run.written.shows)
<span class="cmt">// Will print:</span>
<span class="cmt">// No description</span>
<span class="cmt">//   foo = 1</span>
<span class="cmt">//   bar = 2</span>
<span class="cmt">//   foobar = 3</span></pre><p>(For those struggling with the full power of for-comprehensions, I suggest turning the above example into its unsugared flatmap/map form
to see what is going on. The central point is that <code>foo</code> will have the value 1, <code>bar</code> will have the value 2, and
<code>foobar</code> will have the value 3; the monadic stuff all happens in the background.)</p><h4> Non-Leaf Nodes </h4><p>Non-leaf nodes (branches) are created explicitly by the developer or implicitly by the <a href="LogTreeSyntax.html" class="extype" name="treelog.LogTreeSyntax">LogTreeSyntax</a> under
various conditions.</p><p>The log tree above has a root node with 'No description' and three child (leaf) nodes with descriptions obviously obtained from the
arguments to the right of the <code>~&gt;</code> operators in the for-comprehension. This is because the three leaf nodes explicitly
created in that for-comprehension need to be placed somewhere while the log tree is produced. An obvious thing to do was to make them
child nodes of a branch, which <a href="LogTreeSyntax.html" class="extype" name="treelog.LogTreeSyntax">LogTreeSyntax</a> does, using some rules for when to create a new branch to
contain existing children and when to just add new children to an existing branch.</p><p>However, at the time the branch is created there is no ready description available for it, hence the &quot;No description&quot; text when the tree is
shown using the <code>scalaz.Show</code> defined for it. Producing a hierarchical log isn't much use if we
can't describe the non-leaf elements. We can provide a description in two ways (this looks ugly, but read and it will get more elegant&#8230;):</p><pre><span class="kw">import</span> treelog.LogTreeSyntaxWithoutAnnotations._
<span class="kw">import</span> scalaz.syntax.show._

<span class="kw">val</span> result = <span class="kw">for</span> {
   foo <span class="kw">&lt;-</span> <span class="num">1</span> ~&gt; (<span class="lit">"foo = "</span> + _) <span class="cmt">// Using the overload of ~> that gives us the 'value'</span>
   bar <span class="kw">&lt;-</span> <span class="num">2</span> ~&gt; (<span class="lit">"bar = "</span> + _) <span class="cmt">// so that we can include it in the log messages</span>
   foobar <span class="kw">&lt;-</span> (foo + bar) ~&gt; (<span class="lit">"foobar = "</span> + _)
  } <span class="kw">yield</span> foobar


<span class="kw">val</span> resultWithDescription1 = result ~&gt; <span class="lit">"Adding up"</span>
println(resultWithDescription1.run.written.shows)
<span class="cmt">// Will print:</span>
<span class="cmt">// Adding up</span>
<span class="cmt">//   foo = 1</span>
<span class="cmt">//   bar = 2</span>
<span class="cmt">//   foobar = 3</span>

<span class="kw">val</span> resultWithDescription2 = <span class="lit">"Adding up"</span> ~&lt; result
println(resultWithDescription2.run.written.shows)
<span class="cmt">// Will also print:</span>
<span class="cmt">// Adding up</span>
<span class="cmt">//   foo = 1</span>
<span class="cmt">//   bar = 2</span>
<span class="cmt">//   foobar = 3</span></pre><p>The first approach (<code>resultWithDescription1</code> using <code>~gt;</code>) will generally be used when a method/function used to provide an intermediate result
in the middle of a for-comprehension returns an undescribed root node. Then the code flows quite nicely thus:</p><pre><span class="kw">val</span> result = <span class="kw">for</span> {
 something <span class="kw">&lt;-</span> doSomething() ~&gt; <span class="lit">"Something has been done"</span>
 more <span class="kw">&lt;-</span> doMore(something) ~&gt; <span class="lit">"More has been done"</span>
} <span class="kw">yield</span> more</pre><p>Here, <code>doSomething()</code> and <code>doMore(...)</code> return DescribedComputations carrying a log tree with an undescribed root node.
They have been given descriptions in the above for-comprehension.</p><p>The second approach (<code>resultWithDescription2</code> using <code>~&lt;</code>) will generally be used when a for-comprehension yields a
<code>DescribedComputation</code> (which will always have a log tree with an undescribed root node if the for-comprehension has more than
one generator), and you want to immediately give the root node a description. In this case, it is more natural to write:</p><pre><span class="kw">val</span> result = <span class="lit">"Adding up"</span> ~&lt; {
<span class="kw">for</span> {
  foo <span class="kw">&lt;-</span> <span class="num">1</span> ~&gt; (<span class="lit">"foo = "</span> + _)
  bar <span class="kw">&lt;-</span> <span class="num">2</span> ~&gt; (<span class="lit">"bar = "</span> + _)
  foobar <span class="kw">&lt;-</span> (foo + bar) ~&gt; (<span class="lit">"foobar = "</span> + _)
} <span class="kw">yield</span> foobar
}</pre><p>Both of these approaches are demonstrated in the
<a href="https://github.com/lancewalton/treelog/blob/master/src/test/scala/QuadraticRootsExample.scala" target="_blank">quadratic roots example</a>. There is no good
reason for mixing the two approaches in that example, other than for purposes of demonstration.</p><p><code>~&lt;</code> works not only for <code>DescribedComputation</code>, but for any <code>F[DescribedComputation]</code> as long as
<code>F</code> has a <code>scalaz.Monad</code> and a <code>scalaz.Traverse</code> defined and available in implicit scope.
See <a href="LogTreeSyntax$BranchLabelingSyntax.html" class="extype" name="treelog.LogTreeSyntax.BranchLabelingSyntax">BranchLabelingSyntax</a>.</p><h3> Special Lifting </h3><h4> Boolean, Option and \/ </h4><p><code>Boolean</code>, <code>Option</code> and <code>\/</code> (scalaz's 'Either'), have some special syntax <code>~&gt;?</code> associated with
them to allow <code>true</code>, <code>Some(.)</code> and <code>\/-(.)</code> to be treated as successful computational outcomes, and
<code>false</code>, <code>None</code> and <code>-\/(.)</code> to be treated as failure conditions. For example:</p><pre><span class="kw">val</span> result = <span class="kw">false</span> ~&gt;? <span class="lit">"Doing a thing with a Boolean"</span>
println(result.run.value)
<span class="cmt">// Will print -\/(Doing a thing with a Boolean) (note that it's a 'left')</span>

println(result.run.written.shows)
<span class="cmt">// Will print:</span>
<span class="cmt">// Failed: Doing a thing with a Boolean</span></pre><p>Notice how the <code>Show</code> for the <a href="Tree.html" class="extype" name="treelog.Tree">Tree</a> indicates that the result is a failure. This failure information exists in the
<a href="TreeNode.html" class="extype" name="treelog.TreeNode">TreeNode's</a> <code>label</code> property (which is generic in <a href="TreeNode.html" class="extype" name="treelog.TreeNode">TreeNode</a> and instantiated as a
<a href="LogTreeLabel.html" class="extype" name="treelog.LogTreeLabel">LogTreeLabel</a> in the <a href="LogTreeSyntax.html" class="extype" name="treelog.LogTreeSyntax">LogTreeSyntax</a> methods.</p><p><code>~&gt;?</code> is overloaded for each of the three types above to allow either a simple description to be given (as in the example above)
or for different descriptions to be given in the success versus failure case. Also, in the case of <code>Option</code> and <code>\/</code>,
overloads are provided to pass the values contained. See <a href="LogTreeSyntax$BooleanSyntax.html" class="extype" name="treelog.LogTreeSyntax.BooleanSyntax">BooleanSyntax</a>,
<a href="LogTreeSyntax$OptionSyntax.html" class="extype" name="treelog.LogTreeSyntax.OptionSyntax">OptionSyntax</a>, <a href="LogTreeSyntax$EitherSyntax.html" class="extype" name="treelog.LogTreeSyntax.EitherSyntax">EitherSyntax</a>.</p><p>Note that it is easy to get drawn into always using this syntax for these three types. But sometimes, for example, a <code>Boolean</code>
<code>false</code> does not indicate a failure in a computation and so <code>~&gt;?</code> is not appropriate. Keep in mind that 'failure'
means that the computation will stop, whereas 'success' will mean that the computation will continue.</p><h4> Traversable Monads </h4><p>Suppose you have a <code>List[A]</code> and a function <code>f: A => DescribedComputation[B]</code>, and you want to apply <code>f(.)</code>
to each element of the list to produce <code>DescribedComputations</code> for each element. That's easy enough. But suppose you now want
to take all of the 'values' (<code>vs</code>) contained in the list of <code>DescribedComputations</code> thus produced, and create a new
<code>DescribedComputation</code> whose value is <code>vs</code> and whose log tree is a branch with a description and whose children
are the log trees resulting from each application of <code>f(.)</code>.</p><p>We needed to do precisely that very often, so we wrote some syntax for it:</p><pre><span class="kw">import</span> treelog.LogTreeSyntaxWithoutAnnotations._
<span class="kw">import</span> scalaz.syntax.show._
<span class="kw">import</span> scalaz.std.list._

<span class="kw">val</span> result = <span class="std">List</span>(<span class="num">1</span>, <span class="num">2</span>, <span class="num">3</span>) ~&gt;* (<span class="lit">"Double the values"</span>, x <span class="kw">=&gt;</span> (x * <span class="num">2</span>) ~&gt; (y <span class="kw">=&gt;</span> s<span class="lit">"Double $x = $y"</span>))

println(result.run.value)
<span class="cmt">// Will print \/-(List(2, 4, 6))</span>

println(result.run.written.shows)
<span class="cmt">// Will print:</span>
<span class="cmt">// Double the values</span>
<span class="cmt">//   Double 1 = 2</span>
<span class="cmt">//   Double 2 = 4</span>
<span class="cmt">//   Double 3 = 6</span></pre><p>This is particularly useful if there is a possibility that <code>f(.)</code> can produce <code>DescribedComputations</code> that represent failures,
because hoisting children into a branch of a log tree gives the branch a successful status only if all of the children are successful (this is true
of all syntax that does this). Hence:</p><pre><span class="kw">val</span> result = <span class="std">List</span>(<span class="num">1</span>, <span class="num">2</span>, <span class="num">3</span>) ~&gt;* (<span class="lit">"All even"</span>, x <span class="kw">=&gt;</span> (x % <span class="num">2</span> == <span class="num">0</span>) ~&gt;? s<span class="lit">"Testing if $x is even"</span>)

println(result.run.value)
<span class="cmt">// Will print -\/(All even) - Notice that it's a 'left', meaning failure</span>

println(result.run.written.shows)
<span class="cmt">// Will print:</span>
<span class="cmt">// Failed: All even</span>
<span class="cmt">//   Failed: Testing if 1 is even</span>
<span class="cmt">//   Testing if 2 is even</span>
<span class="cmt">//   Failed: Testing if 3 is even</span></pre><p><code>~&gt;*</code> works not only for <code>List</code>, but for all kinds that have a <code>scalaz.Monad</code> and a <code>scalaz.Traverse</code>
defined and available in implicit scope. See <a href="LogTreeSyntax$TraversableMonadSyntax.html" class="extype" name="treelog.LogTreeSyntax.TraversableMonadSyntax">TraversableMonadSyntax</a>.</p><h4> Annotations </h4><p>Nodes in the log tree can be annotated with important information for your program to use later. This is useful, for example, when you want to audit
a process that affects multiple entities, and you want to make sure that the audit trail is associated with each of the modified entities. You can use
the annotation facility to carry the key (or something richer) for each modified entity.</p><p>The <code>~~</code> (see <a href="LogTreeSyntax$AnnotationsSyntax.html" class="extype" name="treelog.LogTreeSyntax.AnnotationsSyntax">AnnotationsSyntax</a>) is provided for this purpose. It can be applied to
any <code>DescribedComputation</code> and it will add the given annotation to the set of annotations at the current root node of the log
tree. Annotations can be of any type, but must all be of the same type for a particular log tree. You choose the type of annotations by instantiating
the 'Annotation' type parameter of <a href="LogTreeSyntax.html" class="extype" name="treelog.LogTreeSyntax">LogTreeSyntax</a></p><p>Here is a simple example using <code>Strings</code> as the annotations type:</p><pre><span class="kw">val</span> stringAnnotateableLogTreeSyntax = <span class="kw">new</span> treelog.LogTreeSyntax[<span class="std">String</span>] {}
<span class="kw">import</span> stringAnnotateableLogTreeSyntax._
<span class="kw">import</span> scalaz.syntax.show._
<span class="kw">import</span> scalaz.std.string._

<span class="kw">val</span> result = <span class="num">1</span> ~&gt; <span class="lit">"This is the description"</span> ~~ <span class="lit">"This is the annotation"</span>

println(result.run.value)
<span class="cmt">// Will print \/-(1)</span>

println(result.run.written.shows)
<span class="cmt">// Will print:</span>
<span class="cmt">// This is the description - ["This is the annotation"]</span></pre><p>See the <a href="https://github.com/lancewalton/treelog/blob/master/src/test/scala/AnnotationsExample.scala" target="_blank">annotations example</a>
for a more comprehensive example.
</p></div><div class="toggleContainer block">
          <span class="toggle">Linear Supertypes</span>
          <div class="superTypes hiddenContent"><span class="extype" name="scala.AnyRef">AnyRef</span>, <span class="extype" name="scala.Any">Any</span></div>
        </div></div>
        

      <div id="mbrsel">
        <div id="textfilter"><span class="pre"></span><span class="input"><input id="mbrsel-input" type="text" accesskey="/" /></span><span class="post"></span></div>
        <div id="order">
              <span class="filtertype">Ordering</span>
              <ol>
                
                <li class="alpha in"><span>Alphabetic</span></li>
                <li class="inherit out"><span>By inheritance</span></li>
              </ol>
            </div>
        <div id="ancestors">
                <span class="filtertype">Inherited<br />
                </span>
                <ol id="linearization">
                  <li class="in" name="treelog"><span>treelog</span></li><li class="in" name="scala.AnyRef"><span>AnyRef</span></li><li class="in" name="scala.Any"><span>Any</span></li>
                </ol>
              </div><div id="ancestors">
            <span class="filtertype"></span>
            <ol>
              <li class="hideall out"><span>Hide All</span></li>
              <li class="showall in"><span>Show all</span></li>
            </ol>
            <a href="http://docs.scala-lang.org/overviews/scaladoc/usage.html#members" target="_blank">Learn more about member selection</a>
          </div>
        <div id="visbl">
            <span class="filtertype">Visibility</span>
            <ol><li class="public in"><span>Public</span></li><li class="all out"><span>All</span></li></ol>
          </div>
      </div>

      <div id="template">
        <div id="allMembers">
        

        <div id="types" class="types members">
              <h3>Type Members</h3>
              <ol><li name="treelog.DescribedLogTreeLabel" visbl="pub" data-isabs="false" fullComment="no" group="Ungrouped">
      <a id="DescribedLogTreeLabel[Annotation]extendsLogTreeLabel[Annotation]withProductwithSerializable"></a>
      <a id="DescribedLogTreeLabel[Annotation]:DescribedLogTreeLabel[Annotation]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">case class</span>
      </span>
      <span class="symbol">
        <a href="DescribedLogTreeLabel.html"><span class="name">DescribedLogTreeLabel</span></a><span class="tparams">[<span name="Annotation">Annotation</span>]</span><span class="params">(<span name="description">description: <span class="extype" name="scala.Predef.String">String</span></span>, <span name="success">success: <span class="extype" name="scala.Boolean">Boolean</span></span>, <span name="annotations">annotations: <span class="extype" name="scala.Predef.Set">Set</span>[<span class="extype" name="treelog.DescribedLogTreeLabel.Annotation">Annotation</span>] = <span class="defval" name="scala.this.Predef.Set.apply[Annotation]()">...</span></span>)</span><span class="result"> extends <a href="LogTreeLabel.html" class="extype" name="treelog.LogTreeLabel">LogTreeLabel</a>[<span class="extype" name="treelog.DescribedLogTreeLabel.Annotation">Annotation</span>] with <span class="extype" name="scala.Product">Product</span> with <span class="extype" name="scala.Serializable">Serializable</span></span>
      </span>
      </h4>
      
    </li><li name="treelog.LogTreeLabel" visbl="pub" data-isabs="true" fullComment="no" group="Ungrouped">
      <a id="LogTreeLabel[Annotation]extendsAnyRef"></a>
      <a id="LogTreeLabel[Annotation]:LogTreeLabel[Annotation]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">sealed </span>
        <span class="kind">trait</span>
      </span>
      <span class="symbol">
        <a href="LogTreeLabel.html"><span class="name">LogTreeLabel</span></a><span class="tparams">[<span name="Annotation">Annotation</span>]</span><span class="result"> extends <span class="extype" name="scala.AnyRef">AnyRef</span></span>
      </span>
      </h4>
      
    </li><li name="treelog.LogTreeSyntax" visbl="pub" data-isabs="true" fullComment="no" group="Ungrouped">
      <a id="LogTreeSyntax[Annotation]extendsAnyRef"></a>
      <a id="LogTreeSyntax[Annotation]:LogTreeSyntax[Annotation]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">trait</span>
      </span>
      <span class="symbol">
        <a href="LogTreeSyntax.html"><span class="name">LogTreeSyntax</span></a><span class="tparams">[<span name="Annotation">Annotation</span>]</span><span class="result"> extends <span class="extype" name="scala.AnyRef">AnyRef</span></span>
      </span>
      </h4>
      <p class="comment cmt">See the <a href="" class="extype" name="treelog">treelog</a> package documentation for a brief introduction to treelog and also,
<a href="https://github.com/lancewalton/treelog#using-treelog---examples" target="_blank">examples on GitHub</a> to get started.</p>
    </li><li name="treelog.Tree" visbl="pub" data-isabs="true" fullComment="no" group="Ungrouped">
      <a id="Tree[+Label]extendsAnyRef"></a>
      <a id="Tree[+Label]:Tree[Label]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">sealed </span>
        <span class="kind">trait</span>
      </span>
      <span class="symbol">
        <a href="Tree.html"><span class="name">Tree</span></a><span class="tparams">[<span name="Label">+Label</span>]</span><span class="result"> extends <span class="extype" name="scala.AnyRef">AnyRef</span></span>
      </span>
      </h4>
      
    </li><li name="treelog.TreeNode" visbl="pub" data-isabs="false" fullComment="no" group="Ungrouped">
      <a id="TreeNode[Label]extendsTree[Label]withProductwithSerializable"></a>
      <a id="TreeNode[Label]:TreeNode[Label]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">case class</span>
      </span>
      <span class="symbol">
        <a href="TreeNode.html"><span class="name">TreeNode</span></a><span class="tparams">[<span name="Label">Label</span>]</span><span class="params">(<span name="label">label: <span class="extype" name="treelog.TreeNode.Label">Label</span></span>, <span name="children">children: <span class="extype" name="scala.List">List</span>[<a href="Tree.html" class="extype" name="treelog.Tree">Tree</a>[<span class="extype" name="treelog.TreeNode.Label">Label</span>]] = <span class="symbol">immutable.this.Nil</span></span>)</span><span class="result"> extends <a href="Tree.html" class="extype" name="treelog.Tree">Tree</a>[<span class="extype" name="treelog.TreeNode.Label">Label</span>] with <span class="extype" name="scala.Product">Product</span> with <span class="extype" name="scala.Serializable">Serializable</span></span>
      </span>
      </h4>
      
    </li><li name="treelog.UndescribedLogTreeLabel" visbl="pub" data-isabs="false" fullComment="no" group="Ungrouped">
      <a id="UndescribedLogTreeLabel[Annotation]extendsLogTreeLabel[Annotation]withProductwithSerializable"></a>
      <a id="UndescribedLogTreeLabel[Annotation]:UndescribedLogTreeLabel[Annotation]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">case class</span>
      </span>
      <span class="symbol">
        <a href="UndescribedLogTreeLabel.html"><span class="name">UndescribedLogTreeLabel</span></a><span class="tparams">[<span name="Annotation">Annotation</span>]</span><span class="params">(<span name="success">success: <span class="extype" name="scala.Boolean">Boolean</span></span>, <span name="annotations">annotations: <span class="extype" name="scala.Predef.Set">Set</span>[<span class="extype" name="treelog.UndescribedLogTreeLabel.Annotation">Annotation</span>] = <span class="defval" name="scala.this.Predef.Set.apply[Annotation]()">...</span></span>)</span><span class="result"> extends <a href="LogTreeLabel.html" class="extype" name="treelog.LogTreeLabel">LogTreeLabel</a>[<span class="extype" name="treelog.UndescribedLogTreeLabel.Annotation">Annotation</span>] with <span class="extype" name="scala.Product">Product</span> with <span class="extype" name="scala.Serializable">Serializable</span></span>
      </span>
      </h4>
      
    </li></ol>
            </div>

        

        <div id="values" class="values members">
              <h3>Value Members</h3>
              <ol><li name="treelog.LogTreeSyntaxWithoutAnnotations" visbl="pub" data-isabs="false" fullComment="no" group="Ungrouped">
      <a id="LogTreeSyntaxWithoutAnnotations"></a>
      <a id="LogTreeSyntaxWithoutAnnotations:LogTreeSyntaxWithoutAnnotations"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">object</span>
      </span>
      <span class="symbol">
        <a href="LogTreeSyntaxWithoutAnnotations$.html"><span class="name">LogTreeSyntaxWithoutAnnotations</span></a><span class="result"> extends <a href="LogTreeSyntax.html" class="extype" name="treelog.LogTreeSyntax">LogTreeSyntax</a>[<span class="extype" name="scala.Nothing">Nothing</span>]</span>
      </span>
      </h4>
      
    </li><li name="treelog.NilTree" visbl="pub" data-isabs="false" fullComment="no" group="Ungrouped">
      <a id="NilTree"></a>
      <a id="NilTree:NilTree"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">object</span>
      </span>
      <span class="symbol">
        <a href="NilTree$.html"><span class="name">NilTree</span></a><span class="result"> extends <a href="Tree.html" class="extype" name="treelog.Tree">Tree</a>[<span class="extype" name="scala.Nothing">Nothing</span>] with <span class="extype" name="scala.Product">Product</span> with <span class="extype" name="scala.Serializable">Serializable</span></span>
      </span>
      </h4>
      
    </li></ol>
            </div>

        

        
        </div>

        <div id="inheritedMembers">
        <div class="parent" name="scala.AnyRef">
              <h3>Inherited from <span class="extype" name="scala.AnyRef">AnyRef</span></h3>
            </div><div class="parent" name="scala.Any">
              <h3>Inherited from <span class="extype" name="scala.Any">Any</span></h3>
            </div>
        
        </div>

        <div id="groupedMembers">
        <div class="group" name="Ungrouped">
              <h3>Ungrouped</h3>
              
            </div>
        </div>

      </div>

      <div id="tooltip"></div>

      <div id="footer">  </div>
      <script defer="defer" type="text/javascript" id="jquery-js" src="../lib/jquery.js"></script><script defer="defer" type="text/javascript" id="jquery-ui-js" src="../lib/jquery-ui.js"></script><script defer="defer" type="text/javascript" id="tools-tooltip-js" src="../lib/tools.tooltip.js"></script><script defer="defer" type="text/javascript" id="template-js" src="../lib/template.js"></script>
    </body>
      </html>